React Notes
===========

cd reactshop 
npm install -g create-react-app
npx create-react-app frontend

cd frontend
npm start		// Starts the development server.
npm run build	// Bundles the app into static files for production.
npm test		// Starts the test runner.

VS Code plugins
--------------
ES7 React/Redux/GraphQL/React-Native snippets
Auto Rename Tag
Bracket Pair Colorizer
JavaScript (ES6) Code snippets
Prettier - Code formatter
    - Format On Save    -Enable setting
    - Prettier: Jsx Single Quote
    - Prettier: Semi       - uncheck
    - Prettier: Single Quote
    - Prettier: Tab Width   2

VsCode Explorer fix
"workbench.tree.indent": 12
    
kb shortcuts
rafce - ReactArrowFunctionComponentExport
rcc - React Class Component

https://reactrouter.com/web/api/Link
https://react-bootstrap.github.io/
https://react-bootstrap.github.io/components/
https://fontawesome.com/v5.15/icons?d=gallery&p=2&m=free
https://fonts.google.com/icons
https://getbootstrap.com/docs/4.0/utilities/spacing/#notation
https://getbootstrap.com/docs/5.1/utilities/text/
https://material-ui.com/
https://bootswatch.com/
https://cdnjs.com/libraries/font-awesome
https://github.com/bradtraversy/proshop_mern
https://materializecss.com/grid.html
// npm install react-bootstrap bootstrap
npm install react-bootstrap

- download bootstrap.min.css from bootswatch.com and import in index.js
- from https://cdnjs.com/libraries/font-awesome "Copy Link Tag" for all.min.css and include it in index.html

- Convert commonjs - require() syntax to 
    import style syntax which are ECMAScript modules (available in Nodejs 14.4+) 
    
const express = require('express')      // commonjs modules syntax
import { Express } from 'express'       // ES6 modules (available in Node 14.4+)

module.exports = products       // commonjs export
export default products         // ES6 export

- frontend/package.json 
    "proxy": "http://localhost:5000",

Frontend
=========
npm i react-router-dom react-router-bootstrap
npm i axios
npm i mongoose 
npm i colors 
npm i bcryptjs 
npm i express-async-handler 
npm i redux react-redux redux-thunk redux-devtools-extension 
- "React Dev tools" 
- "Redux Dev tools" chrome extension

Backend
===========
GET     /api/products
POST    /api/products
PUT     /api/products/25
DELETE  /api/products/25

cd reactshop
npm init
    - entry point: server.js
npm i express
// node backend/server
npm start

- useState() hook
    - We call it inside a function component to add some local state to it. 
    - React will preserve this state between re-renders. 
    - useState returns a pair: the current state value and a function that lets you update it. 
    - You can call this function from an event handler or somewhere else. 
    - It’s similar to this.setState in a class, except it doesn’t merge the old and new state together.
    e.g const [products, setProduct] = useState([])
- useEffect() hook
    - By using this Hook, you tell React that your component needs to do something after render. 
    - React will remember the function you passed (we’ll refer to it as our “effect”), and call it later 
    after performing the DOM updates.
    - Data fetching, setting up a subscription, and manually changing the DOM in React components are all 
    examples of side effects or just effects

// reactshop/package.json
npm i -D nodemon concurrently       // dev dependencies (only needed for development)
nodemon - automatically restars the node application when file changes in the directory are detected
    - nodemon is a replacement wrapper for node

  "scripts": {
    "start": "node backend/server",
    "server": "nodemon backend/server",
    "client": "npm start --prefix frontend",
    "dev": "concurrently \"npm run server\" \"npm run client\""
  }
  
npm i dotenv        // lets you access properties using e.g. process.env.PORT
cat .env            // add .env in .gitignore
NODE_ENV = development
PORT = 5000

- To use ES modules
    in package.json add following
    "type": "module",
    
MongoDB Compass - GUI and Query tool for MongoDB
Add My Own Data
    DB: reactshop
    Collection: products
// .env     - add following    
MONGO_URI = mongodb+srv://<dbusername>:<password>@<cluster-name>/<database>?retryWrites=true&w=majority
npm i mongoose
npm i bcryptjs

npm run data:import     // import prod data into mongodb

npm i express-async-handler
- Simple middleware for handling exceptions inside of async express routes and passing them to your express error handlers.

- What does asyncHandler do ?
    - Saves you writing your own try/catch for async/await and passes error on to next. e.g.
    
    import asyncHandler from 'express-async-handler'
    express.get('/', asyncHandler(async (req, res, next) => {
        const bar = await foo.findAll();
        res.send(bar)
    }))
    
    - Without asyncHandler you'd need:
    express.get('/',(req, res, next) => {
        foo.findAll()
        .then ( bar => {
           res.send(bar)
         } )
        .catch(next); // error passed on to the error handling route
    })

Redux
------
- https://redux.js.org/tutorials/essentials/part-1-overview-concepts
- Redux is a pattern and library for managing and updating application state, using events called "actions". I
- Redux helps you manage "global" state - state that is needed across many parts of your application.
- The patterns and tools provided by Redux make it easier to understand when, where, why, and how the state in your 
    application is being updated, and how your application logic will behave when those changes occur.
- Redux helps you deal with shared state management,
- Redux is more useful when:
    You have large amounts of application state that are needed in many places in the app
    The app state is updated frequently over time
    The logic to update that state may be complex
    The app has a medium or large-sized codebase, and might be worked on by many people
- application parts
    - state - data in current state that drives our app
    - view -  UI based on the current state
    - actions - events that occur in the app based on user input, and trigger updates in the state
- Challenge?
    - multiple components that need to share and use the same state, especially if those components are located in
     different parts of the application
- Sol
    - extract the shared state from the components, and put it into a centralized location outside the component tree. 
     With this, any component can access the state or trigger actions, no matter where they are in the tree!
- basic idea behind Redux: a single centralized place to contain the global state in your application, 
    and specific patterns to follow when updating that state to make the code predictable.

Actions:
- An action is a plain JavaScript object that has a type field and payload.
- You can think of an action as an event that describes something that happened in the application.

Reducers:
- A reducer is a function that receives the current state and an action object, decides how to update the 
state if necessary, and returns the new state: (state, action) => newState. 
- You can think of a reducer as an event listener which handles events based on the received action (event) type.

- Reducers must always follow some specific rules:
    - They should only calculate the new state value based on the state and action arguments
    - They are not allowed to modify the existing state. Instead, they must make immutable updates, by copying 
    the existing state and making changes to the copied values.
    - They must not do any asynchronous logic, calculate random values, or cause other "side effects"
- logic inside reducer functions typically follows the same series of steps:
    - Check to see if the reducer cares about this action
        - If so, make a copy of the state, update the copy with new values, and return it
    - Otherwise, return the existing state unchanged

Store:
- The current Redux application state lives in an object called the store
- store is created by passing in a reducer, and has a method called getState that returns the current state value

Dispatch:
- The Redux store has a method called dispatch. 
- The only way to update the state is to call store.dispatch() and pass in an action object. 
- The store will run its reducer function and save the new state value inside, and we can call getState() to 
 retrieve the updated value:
- You can think of dispatching actions as "triggering an event" in the application. Something happened, and we want
 the store to know about it. Reducers act like event listeners, and when they hear an action they are interested 
 in, they update the state in response.

Selectors:
- Selectors are functions that know how to extract specific pieces of information from a store state value.

Steps
------
Initial setup:
    - A Redux store is created using a root reducer function
    - The store calls the root reducer once, and saves the return value as its initial state
    - When the UI is first rendered, UI components access the current state of the Redux store, and use that data to 
    decide what to render. They also subscribe to any future store updates so they can know if the state has changed.
Updates:
    - Something happens in the app, such as a user clicking a button
    - The app code dispatches an action to the Redux store, like dispatch({type: 'counter/increment'})
    - The store runs the reducer function again with the previous state and the current action, and saves the return 
    value as the new state
    - The store notifies all parts of the UI that are subscribed that the store has been updated
    - Each UI component that needs data from the store checks to see if the parts of the state they need have changed.
    - Each component that sees its data has changed forces a re-render with the new data, so it can update what's 
    shown on the screen
        

1. create constants
2. create reducer
3. add reducer to store.js
4. create action
5. update Screen e.g. HomeScreen

store.js
    const reducer = combineReducers({
        cart: cartReducer, })
    const store = createStore(
      reducer,
      initialState,
      composeWithDevTools(applyMiddleware(...middleware))
    )

CartScreen.js      -->      cartActions.js      -->       cartReducer.js
removeFromCartHandler():    removeFromCart(id):             cartReducer():
  dispatch(                   dispatch({                      case CART_REMOVE_ITEM:
   removeFromCart(id))          type: CART_REMOVE_ITEM,       return {
                                payload: id })                  ...state,
                              localStorage.setItem()            cartItems: state.cartItems.filter() }
                                               
- npm i jsonwebtoken      

